# 策略模式（Strategy Pattern）完全解析

## 一、什么是策略模式？

策略模式是一种**行为型设计模式**，它定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户端。

🌰 **生活比喻**：
想象你要去旅行，可以选择不同的交通工具（策略）：

- 自行车（环保但慢）
- 汽车（快但贵） 
- 公交车（便宜但拥挤）
每种交通方式都是一种"策略"，你可以根据情况自由选择，而旅行的目的地（客户端）不会因为你的选择而改变。

## 二、策略模式的三要素

### 1. 策略接口（Strategy Interface）
```java
public interface TravelStrategy {
    void goToDestination();
}
```

### 2. 具体策略类（Concrete Strategies）
```java
public class BikeStrategy implements TravelStrategy {
    @Override
    public void goToDestination() {
        System.out.println("骑自行车去目的地，耗时60分钟");
    }
}

public class CarStrategy implements TravelStrategy {
    @Override
    public void goToDestination() {
        System.out.println("开车去目的地，耗时20分钟");
    }
}
```

### 3. 上下文类（Context）
```java
public class Traveler {
    private TravelStrategy strategy;
    
    public void setStrategy(TravelStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void travel() {
        strategy.goToDestination();
    }
}
```



## 三、代码示范

```java
// 1. 策略接口
public interface PaymentStrategy {
    void pay(int amount);
}

// 2. 具体策略
public class CreditCardStrategy implements PaymentStrategy {
    private String cardNumber;
    
    public CreditCardStrategy(String cardNumber) {
        this.cardNumber = cardNumber;
    }
    
    @Override
    public void pay(int amount) {
        System.out.println(amount + "元，使用信用卡支付，卡号：" + cardNumber);
    }
}

public class AlipayStrategy implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println(amount + "元，使用支付宝支付");
    }
}

// 3. 上下文类
public class ShoppingCart {
    private PaymentStrategy strategy;
    
    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void checkout(int amount) {
        strategy.pay(amount);
    }
}

// 4. 客户端使用
public class Client {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        
        // 使用支付宝支付
        cart.setPaymentStrategy(new AlipayStrategy());
        cart.checkout(100);
        
        // 切换为信用卡支付
        cart.setPaymentStrategy(new CreditCardStrategy("1234-5678"));
        cart.checkout(200);
    }
}
```

## 五、策略模式的优点

1. **开闭原则**：无需修改上下文即可添加新策略
2. **消除条件语句**：替代大量的if-else或switch-case
3. **提高可扩展性**：新策略易于添加
4. **算法复用**：不同上下文可以共享策略

## 六、策略模式 vs 状态模式

| 特性     | 策略模式             | 状态模式                   |
| -------- | -------------------- | -------------------------- |
| 目的     | 灵活替换算法         | 对象内部状态改变时改变行为 |
| 切换控制 | 客户端控制           | 状态类自身控制             |
| 应用场景 | 支付方式、排序算法等 | 订单状态、工作流程等       |

## 七、实际应用场景

1. **支付系统**：支付宝/微信/信用卡等支付方式
2. **游戏开发**：不同角色的攻击策略
3. **排序算法**：快速排序/归并排序/冒泡排序等切换
4. **导航系统**：多种路径规划算法
5. **折扣系统**：会员折扣/满减/促销等不同计算策略

## 八、面试常见问题

### Q1：策略模式和工厂模式有什么区别？
**答**：
- 工厂模式关注**对象创建**
- 策略模式关注**行为封装**
- 常组合使用：工厂创建具体的策略对象

### Q2：什么情况下不应该使用策略模式？
**答**：
1. 如果只有1-2种算法且很少变化
2. 如果算法需要访问上下文内部状态
3. 客户端需要知道具体策略的实现细节时

## 九、最佳实践建议

1. **使用枚举简化策略选择**：
```java
public enum TransportType {
    BIKE(new BikeStrategy()),
    CAR(new CarStrategy());
    
    private TravelStrategy strategy;
    
    TransportType(TravelStrategy strategy) {
        this.strategy = strategy;
    }
    
    public TravelStrategy getStrategy() {
        return strategy;
    }
}
```

2. **结合Spring使用**：
```java
@Service
public class PaymentService {
    private Map<String, PaymentStrategy> strategies;
    
    // Spring会自动注入所有实现PaymentStrategy的Bean
    public PaymentService(List<PaymentStrategy> strategyList) {
        strategies = strategyList.stream()
            .collect(Collectors.toMap(
                s -> s.getClass().getSimpleName(),
                Function.identity()
            ));
    }
    
    public void pay(String strategyName, int amount) {
        strategies.get(strategyName).pay(amount);
    }
}
```

3. **Lambda表达式简化**（Java8+）：
```java
public class Calculator {
    private BinaryOperator<Integer> strategy;
    
    public void setStrategy(BinaryOperator<Integer> strategy) {
        this.strategy = strategy;
    }
    
    public int calculate(int a, int b) {
        return strategy.apply(a, b);
    }
}

// 使用
Calculator calc = new Calculator();
calc.setStrategy((a, b) -> a + b); // 加法策略
calc.setStrategy((a, b) -> a * b); // 乘法策略
```
# Java Set集合总结笔记

## 一、Set核心概念
✅ **本质**：不允许重复元素的集合（数学中的"集合"概念）  
✅ **核心特性**：
- 元素唯一性（自动去重）
- 不保证顺序（具体顺序取决于实现类）
- 基于`equals()`和`hashCode()`判断元素是否相同

## 二、三大实现类对比

| 特性             | HashSet    | LinkedHashSet    | TreeSet             |
| ---------------- | ---------- | ---------------- | ------------------- |
| **数据结构**     | 哈希表     | 哈希表+链表      | 红黑树              |
| **排序方式**     | 无顺序     | 插入顺序         | 自然排序/自定义排序 |
| **性能(O符号)**  | O(1)       | 接近O(1)         | O(log n)            |
| **允许null元素** | 是         | 是               | 否                  |
| **线程安全**     | 非线程安全 | 非线程安全       | 非线程安全          |
| **最佳使用场景** | 快速查找   | 需要保持插入顺序 | 需要自动排序        |

## 三、常用初始化方式

### 1. 空集合初始化
```java
Set<String> set1 = new HashSet<>();      // 默认初始容量16
Set<String> set2 = new HashSet<>(100);   // 指定初始容量
Set<String> set3 = new LinkedHashSet<>();
Set<String> set4 = new TreeSet<>();
```

### 2. 带初始值的初始化
```java
// 使用Arrays.asList
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3));

// Java 9+的工厂方法（不可变集合）
Set<Integer> set2 = Set.of(1, 2, 3);

// 双括号初始化（匿名内部类，不推荐）
Set<String> set3 = new HashSet<>() {{
    add("A");
    add("B");
}};
```

## 四、核心操作方法

### 1. 基本操作
```java
set.add("apple");         // 添加元素
set.remove("apple");      // 删除元素
set.contains("apple");    // 检查存在
set.size();               // 元素数量
set.isEmpty();            // 是否为空
set.clear();              // 清空集合
```

### 2. 集合运算
```java
// 并集
set1.addAll(set2); 

// 交集
set1.retainAll(set2);

// 差集
set1.removeAll(set2);

// 判断子集
set1.containsAll(set2);
```

### 3. 遍历方式
```java
// 1. for-each循环
for (String item : set) {
    System.out.println(item);
}

// 2. 使用迭代器
Iterator<String> it = set.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}

// 3. Java 8+ forEach方法
set.forEach(System.out::println);
```

## 五、特殊注意事项

### 1. 元素唯一性实现
- 依赖`equals()`和`hashCode()`方法
- 自定义对象放入Set必须正确重写这两个方法
```java
class Person {
    String name;
    // 必须重写equals和hashCode
    @Override
    public boolean equals(Object o) {...}
    @Override
    public int hashCode() {...}
}
```

### 2. TreeSet的特殊性
- 元素必须实现Comparable接口
- 或创建时提供Comparator
```java
// 自定义排序
Set<String> treeSet = new TreeSet<>((a, b) -> b.compareTo(a));
```

### 3. 线程安全方案
```java
// 方法1：使用Collections工具类
Set<String> safeSet = Collections.synchronizedSet(new HashSet<>());

// 方法2：使用ConcurrentHashMap实现的Set
Set<String> concurrentSet = ConcurrentHashMap.newKeySet();
```

## 六、性能优化建议

1. **HashSet初始化**：
   - 默认负载因子0.75（当元素达到容量的75%时扩容）
   - 预估元素数量可避免频繁扩容
   ```java
   // 预计存放200元素，0.75负载因子
   new HashSet<>(200 / 0.75 + 1);
   ```

2. **选择合适实现**：
   - 纯查找 → HashSet
   - 需要顺序 → LinkedHashSet
   - 需要排序 → TreeSet

3. **大集合处理**：
   - 避免频繁扩容，初始化时指定足够容量
   - 考虑使用不可变集合（`Set.of()`）提高性能

## 七、典型应用场景

1. **数据去重**
```java
List<String> duplicates = ...;
Set<String> unique = new HashSet<>(duplicates);
```

2. **黑名单过滤**
```java
Set<String> blacklist = new HashSet<>(...);
if (blacklist.contains(input)) {
    // 拒绝处理
}
```

3. **关系运算**
```java
// 求两个用户的共同好友
Set<User> friendsA = ...;
Set<User> friendsB = ...;
friendsA.retainAll(friendsB);
```

4. **全局唯一ID管理**
```java
Set<UUID> usedIds = new HashSet<>();
UUID newId = UUID.randomUUID();
while (usedIds.contains(newId)) {
    newId = UUID.randomUUID();
}
```

## 八、常见问题解决方案

1. **保持插入顺序** → 使用LinkedHashSet
2. **需要排序功能** → 使用TreeSet
3. **处理对象集合** → 确保正确重写equals和hashCode
4. **多线程环境** → 使用线程安全版本
5. **需要不可变集合** → 使用Set.of()（Java 9+）
